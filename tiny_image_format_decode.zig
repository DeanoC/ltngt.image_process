// Do Not Edit Autogenerated by tiny_image_format_generator

const std = @import("std");
const TinyImageFormat = @import("tiny_image_format.zig").Format;

const sRGBTable = [256]f32{ 0.0, 3.0353E-4, 6.0705E-4, 9.1058E-4, 0.00121411, 0.00151763, 0.00182116, 0.00212469, 0.00242822, 0.00273174, 0.00303527, 0.00334654, 0.00367651, 0.00402472, 0.00439144, 0.00477695, 0.00518152, 0.00560539, 0.00604883, 0.00651209, 0.00699541, 0.00749903, 0.00802319, 0.00856812, 0.00913406, 0.00972122, 0.01032982, 0.01096009, 0.01161224, 0.01228649, 0.01298303, 0.01370208, 0.01444384, 0.01520851, 0.01599629, 0.01680738, 0.01764195, 0.01850022, 0.01938236, 0.02028856, 0.02121901, 0.02217388, 0.02315336, 0.02415763, 0.02518686, 0.02624122, 0.02732089, 0.02842604, 0.02955683, 0.03071344, 0.03189603, 0.03310476, 0.03433981, 0.03560131, 0.03688945, 0.03820436, 0.03954624, 0.0409152, 0.04231141, 0.04373503, 0.0451862, 0.04666508, 0.04817182, 0.04970656, 0.05126947, 0.05286065, 0.05448028, 0.05612849, 0.05780543, 0.05951124, 0.06124607, 0.06301003, 0.06480328, 0.06662595, 0.06847818, 0.07036011, 0.07227186, 0.07421358, 0.07618539, 0.07818743, 0.08021983, 0.08228271, 0.08437622, 0.08650047, 0.08865561, 0.09084173, 0.09305898, 0.09530748, 0.09758736, 0.09989874, 0.10224175, 0.10461649, 0.10702311, 0.10946172, 0.11193243, 0.11443538, 0.11697067, 0.11953843, 0.1221388, 0.12477184, 0.1274377, 0.13013649, 0.13286833, 0.13563335, 0.13843162, 0.14126331, 0.14412849, 0.14702728, 0.1499598, 0.15292616, 0.15592647, 0.15896086, 0.1620294, 0.16513222, 0.1682694, 0.17144109, 0.17464739, 0.17788841, 0.18116423, 0.18447499, 0.18782076, 0.19120167, 0.19461781, 0.1980693, 0.20155624, 0.20507871, 0.20863685, 0.21223073, 0.21586053, 0.21952623, 0.22322798, 0.22696589, 0.23074007, 0.23455065, 0.23839766, 0.2422812, 0.2462014, 0.25015837, 0.25415218, 0.25818291, 0.26225072, 0.26635566, 0.27049786, 0.27467737, 0.27889434, 0.2831488, 0.2874409, 0.2917707, 0.29613832, 0.30054384, 0.30498737, 0.30946895, 0.31398875, 0.31854683, 0.32314324, 0.32777813, 0.33245158, 0.33716366, 0.34191445, 0.3467041, 0.3515327, 0.35640025, 0.36130688, 0.36625269, 0.37123778, 0.37626222, 0.38132611, 0.38642952, 0.39157256, 0.39675531, 0.40197787, 0.4072403, 0.4125427, 0.41788515, 0.42326775, 0.42869055, 0.43415371, 0.43965724, 0.44520125, 0.45078585, 0.45641106, 0.46207705, 0.46778384, 0.47353154, 0.47932023, 0.48514998, 0.49102089, 0.49693304, 0.50288659, 0.50888145, 0.51491779, 0.52099568, 0.52711523, 0.5332765, 0.53947961, 0.54572457, 0.55201149, 0.55834049, 0.56471163, 0.57112491, 0.57758051, 0.58407849, 0.59061891, 0.59720188, 0.60382742, 0.61049563, 0.61720663, 0.62396044, 0.63075721, 0.63759696, 0.64447975, 0.65140569, 0.65837485, 0.66538733, 0.67244321, 0.67954254, 0.68668544, 0.69387192, 0.70110202, 0.70837593, 0.71569365, 0.72305524, 0.73046088, 0.73791057, 0.74540436, 0.75294232, 0.76052463, 0.76815128, 0.77582234, 0.78353792, 0.79129803, 0.79910284, 0.80695236, 0.81484669, 0.82278585, 0.83076996, 0.83879912, 0.84687328, 0.85499269, 0.86315727, 0.87136722, 0.87962234, 0.88792318, 0.89626938, 0.90466136, 0.91309869, 0.92158204, 0.93011087, 0.93868589, 0.94730657, 0.95597351, 0.96468627, 0.97344548, 0.98225057, 0.99110222, 1.0};

pub fn CanDecodePixelsToF32(fmt: TinyImageFormat) bool {
    switch (fmt) {
        .R1_UNORM => return true,
        .R2_UNORM => return true,
        .R4_UNORM => return true,
        .R4G4_UNORM => return true,
        .G4R4_UNORM => return true,
        .A8_UNORM => return true,
        .R8_UNORM => return true,
        .R8_SNORM => return true,
        .R8_UINT => return true,
        .R8_SINT => return true,
        .R8_SRGB => return true,
        .B2G3R3_UNORM => return true,
        .R4G4B4A4_UNORM => return true,
        .R4G4B4X4_UNORM => return true,
        .B4G4R4A4_UNORM => return true,
        .B4G4R4X4_UNORM => return true,
        .A4R4G4B4_UNORM => return true,
        .X4R4G4B4_UNORM => return true,
        .A4B4G4R4_UNORM => return true,
        .X4B4G4R4_UNORM => return true,
        .R5G6B5_UNORM => return true,
        .B5G6R5_UNORM => return true,
        .R5G5B5A1_UNORM => return true,
        .B5G5R5A1_UNORM => return true,
        .A1R5G5B5_UNORM => return true,
        .A1B5G5R5_UNORM => return true,
        .R5G5B5X1_UNORM => return true,
        .B5G5R5X1_UNORM => return true,
        .X1R5G5B5_UNORM => return true,
        .X1B5G5R5_UNORM => return true,
        .B2G3R3A8_UNORM => return true,
        .R8G8_UNORM => return true,
        .R8G8_SNORM => return true,
        .G8R8_UNORM => return true,
        .G8R8_SNORM => return true,
        .R8G8_UINT => return true,
        .R8G8_SINT => return true,
        .R8G8_SRGB => return true,
        .R16_UNORM => return true,
        .R16_SNORM => return true,
        .R16_UINT => return true,
        .R16_SINT => return true,
        .R16_SFLOAT => return true,
        .R16_SBFLOAT => return true,
        .R8G8B8_UNORM => return true,
        .R8G8B8_SNORM => return true,
        .R8G8B8_UINT => return true,
        .R8G8B8_SINT => return true,
        .R8G8B8_SRGB => return true,
        .B8G8R8_UNORM => return true,
        .B8G8R8_SNORM => return true,
        .B8G8R8_UINT => return true,
        .B8G8R8_SINT => return true,
        .B8G8R8_SRGB => return true,
        .R8G8B8A8_UNORM => return true,
        .R8G8B8A8_SNORM => return true,
        .R8G8B8A8_UINT => return true,
        .R8G8B8A8_SINT => return true,
        .R8G8B8A8_SRGB => return true,
        .B8G8R8A8_UNORM => return true,
        .B8G8R8A8_SNORM => return true,
        .B8G8R8A8_UINT => return true,
        .B8G8R8A8_SINT => return true,
        .B8G8R8A8_SRGB => return true,
        .R8G8B8X8_UNORM => return true,
        .B8G8R8X8_UNORM => return true,
        .R16G16_UNORM => return true,
        .G16R16_UNORM => return true,
        .R16G16_SNORM => return true,
        .G16R16_SNORM => return true,
        .R16G16_UINT => return true,
        .R16G16_SINT => return true,
        .R16G16_SFLOAT => return true,
        .R16G16_SBFLOAT => return true,
        .R32_UINT => return true,
        .R32_SINT => return true,
        .R32_SFLOAT => return true,
        .A2R10G10B10_UNORM => return true,
        .A2R10G10B10_SNORM => return true,
        .A2R10G10B10_UINT => return true,
        .A2R10G10B10_SINT => return true,
        .A2B10G10R10_UNORM => return true,
        .A2B10G10R10_SNORM => return true,
        .A2B10G10R10_UINT => return true,
        .A2B10G10R10_SINT => return true,
        .R10G10B10A2_UNORM => return true,
        .R10G10B10A2_SNORM => return true,
        .R10G10B10A2_UINT => return true,
        .R10G10B10A2_SINT => return true,
        .B10G10R10A2_UNORM => return true,
        .B10G10R10A2_SNORM => return true,
        .B10G10R10A2_UINT => return true,
        .B10G10R10A2_SINT => return true,
        .R16G16B16_UNORM => return true,
        .R16G16B16_SNORM => return true,
        .R16G16B16_UINT => return true,
        .R16G16B16_SINT => return true,
        .R16G16B16_SFLOAT => return true,
        .R16G16B16_SBFLOAT => return true,
        .R16G16B16A16_UNORM => return true,
        .R16G16B16A16_SNORM => return true,
        .R16G16B16A16_UINT => return true,
        .R16G16B16A16_SINT => return true,
        .R16G16B16A16_SFLOAT => return true,
        .R16G16B16A16_SBFLOAT => return true,
        .R32G32_UINT => return true,
        .R32G32_SINT => return true,
        .R32G32_SFLOAT => return true,
        .R32G32B32_UINT => return true,
        .R32G32B32_SINT => return true,
        .R32G32B32_SFLOAT => return true,
        .R32G32B32A32_UINT => return true,
        .R32G32B32A32_SINT => return true,
        .R32G32B32A32_SFLOAT => return true,
        else => return false,
    }
}

const Input = struct { plane0: []const u8, plane1: []const u8 = undefined };

pub fn DecodePixelsToF32(fmt: TinyImageFormat, input: Input, output: []@Vector(4, f32)) void {
    switch (fmt) {
        .R1_UNORM => {
            const format = packed struct { red0: u1, red1: u1, red2: u1, red3: u1, red4: u1, red5: u1, red6: u1, red7: u1 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 8) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 };
                output[(i * 8) + 1] = @Vector(4, f32){ @intToFloat(f32, s.red1), 0.0, 0.0, 1.0 };
                output[(i * 8) + 2] = @Vector(4, f32){ @intToFloat(f32, s.red2), 0.0, 0.0, 1.0 };
                output[(i * 8) + 3] = @Vector(4, f32){ @intToFloat(f32, s.red3), 0.0, 0.0, 1.0 };
                output[(i * 8) + 4] = @Vector(4, f32){ @intToFloat(f32, s.red4), 0.0, 0.0, 1.0 };
                output[(i * 8) + 5] = @Vector(4, f32){ @intToFloat(f32, s.red5), 0.0, 0.0, 1.0 };
                output[(i * 8) + 6] = @Vector(4, f32){ @intToFloat(f32, s.red6), 0.0, 0.0, 1.0 };
                output[(i * 8) + 7] = @Vector(4, f32){ @intToFloat(f32, s.red7), 0.0, 0.0, 1.0 };
            }
        },
        .R2_UNORM => {
            const format = packed struct { red0: u2, red1: u2, red2: u2, red3: u2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 4) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 0.3333333333333333, 1.0, 1.0, 1.0 };
                output[(i * 4) + 1] = @Vector(4, f32){ @intToFloat(f32, s.red1), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 0.3333333333333333, 1.0, 1.0, 1.0 };
                output[(i * 4) + 2] = @Vector(4, f32){ @intToFloat(f32, s.red2), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 0.3333333333333333, 1.0, 1.0, 1.0 };
                output[(i * 4) + 3] = @Vector(4, f32){ @intToFloat(f32, s.red3), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 0.3333333333333333, 1.0, 1.0, 1.0 };
            }
        },
        .R4_UNORM => {
            const format = packed struct { red0: u4, red1: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 2) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 0.06666666666666667, 1.0, 1.0, 1.0 };
                output[(i * 2) + 1] = @Vector(4, f32){ @intToFloat(f32, s.red1), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 0.06666666666666667, 1.0, 1.0, 1.0 };
            }
        },
        .R4G4_UNORM => {
            const format = packed struct { red0: u4, green0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 1.0, 1.0 };
            }
        },
        .G4R4_UNORM => {
            const format = packed struct { green0: u4, red0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 1.0, 1.0 };
            }
        },
        .A8_UNORM => {
            const format = packed struct { alpha0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ 0.0, 0.0, 0.0, @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 1.0, 1.0, 1.0, 0.00392156862745098 };
            }
        },
        .R8_UNORM => {
            const format = packed struct { red0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 0.00392156862745098, 1.0, 1.0, 1.0 };
            }
        },
        .R8_SNORM => {
            const format = packed struct { red0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 0.00784313725490196, 1.0, 1.0, 1.0 };
            }
        },
        .R8_UINT => {
            const format = packed struct { red0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 };
            }
        },
        .R8_SINT => {
            const format = packed struct { red0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 };
            }
        },
        .R8_SRGB => {
            const format = packed struct { red0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ sRGBTable[s.red0], 0.0, 0.0, 1.0 };
            }
        },
        .B2G3R3_UNORM => {
            const format = packed struct { blue0: u2, green0: u3, red0: u3 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.14285714285714285, 0.14285714285714285, 0.3333333333333333, 1.0 };
            }
        },
        .R4G4B4A4_UNORM => {
            const format = packed struct { red0: u4, green0: u4, blue0: u4, alpha0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667 };
            }
        },
        .R4G4B4X4_UNORM => {
            const format = packed struct { red0: u4, green0: u4, blue0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 1.0 };
            }
        },
        .B4G4R4A4_UNORM => {
            const format = packed struct { blue0: u4, green0: u4, red0: u4, alpha0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667 };
            }
        },
        .B4G4R4X4_UNORM => {
            const format = packed struct { blue0: u4, green0: u4, red0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 1.0 };
            }
        },
        .A4R4G4B4_UNORM => {
            const format = packed struct { alpha0: u4, red0: u4, green0: u4, blue0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667 };
            }
        },
        .X4R4G4B4_UNORM => {
            const format = packed struct { red0: u4, green0: u4, blue0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 1.0 };
            }
        },
        .A4B4G4R4_UNORM => {
            const format = packed struct { alpha0: u4, blue0: u4, green0: u4, red0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667 };
            }
        },
        .X4B4G4R4_UNORM => {
            const format = packed struct { blue0: u4, green0: u4, red0: u4 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 1.0 };
            }
        },
        .R5G6B5_UNORM => {
            const format = packed struct { red0: u5, green0: u6, blue0: u5 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.03225806451612903, 0.015873015873015872, 0.03225806451612903, 1.0 };
            }
        },
        .B5G6R5_UNORM => {
            const format = packed struct { blue0: u5, green0: u6, red0: u5 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.03225806451612903, 0.015873015873015872, 0.03225806451612903, 1.0 };
            }
        },
        .R5G5B5A1_UNORM => {
            const format = packed struct { red0: u5, green0: u5, blue0: u5, alpha0: u1 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.03225806451612903, 0.03225806451612903, 0.03225806451612903, 1.0 };
            }
        },
        .B5G5R5A1_UNORM => {
            const format = packed struct { blue0: u5, green0: u5, red0: u5, alpha0: u1 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.03225806451612903, 0.03225806451612903, 0.03225806451612903, 1.0 };
            }
        },
        .A1R5G5B5_UNORM => {
            const format = packed struct { alpha0: u1, red0: u5, green0: u5, blue0: u5 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.03225806451612903, 0.03225806451612903, 0.03225806451612903, 1.0 };
            }
        },
        .A1B5G5R5_UNORM => {
            const format = packed struct { alpha0: u1, blue0: u5, green0: u5, red0: u5 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.03225806451612903, 0.03225806451612903, 0.03225806451612903, 1.0 };
            }
        },
        .R5G5B5X1_UNORM => {
            const format = packed struct { red0: u5, green0: u5, blue0: u5 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.03225806451612903, 0.03225806451612903, 0.03225806451612903, 1.0 };
            }
        },
        .B5G5R5X1_UNORM => {
            const format = packed struct { blue0: u5, green0: u5, red0: u5 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.03225806451612903, 0.03225806451612903, 0.03225806451612903, 1.0 };
            }
        },
        .X1R5G5B5_UNORM => {
            const format = packed struct { red0: u5, green0: u5, blue0: u5 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.03225806451612903, 0.03225806451612903, 0.03225806451612903, 1.0 };
            }
        },
        .X1B5G5R5_UNORM => {
            const format = packed struct { blue0: u5, green0: u5, red0: u5 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.03225806451612903, 0.03225806451612903, 0.03225806451612903, 1.0 };
            }
        },
        .B2G3R3A8_UNORM => {
            const format = packed struct { blue0: u2, green0: u3, red0: u2, alpha0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.3333333333333333, 0.14285714285714285, 0.3333333333333333, 0.00392156862745098 };
            }
        },
        .R8G8_UNORM => {
            const format = packed struct { red0: u8, green0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 0.00392156862745098, 0.00392156862745098, 1.0, 1.0 };
            }
        },
        .R8G8_SNORM => {
            const format = packed struct { red0: i8, green0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 0.00784313725490196, 0.00784313725490196, 1.0, 1.0 };
            }
        },
        .G8R8_UNORM => {
            const format = packed struct { green0: u8, red0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 0.00392156862745098, 0.00392156862745098, 1.0, 1.0 };
            }
        },
        .G8R8_SNORM => {
            const format = packed struct { green0: i8, red0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 0.00784313725490196, 0.00784313725490196, 1.0, 1.0 };
            }
        },
        .R8G8_UINT => {
            const format = packed struct { red0: u8, green0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 };
            }
        },
        .R8G8_SINT => {
            const format = packed struct { red0: i8, green0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 };
            }
        },
        .R8G8_SRGB => {
            const format = packed struct { red0: u8, green0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ sRGBTable[s.red0], sRGBTable[s.green0], 0.0, 1.0 };
            }
        },
        .R16_UNORM => {
            const format = packed struct { red0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 1.5259021896696422E-5, 1.0, 1.0, 1.0 };
            }
        },
        .R16_SNORM => {
            const format = packed struct { red0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 } * @Vector(4, f32){ 3.0518043793392844E-5, 1.0, 1.0, 1.0 };
            }
        },
        .R16_UINT => {
            const format = packed struct { red0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 };
            }
        },
        .R16_SINT => {
            const format = packed struct { red0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 };
            }
        },
        .R16_SFLOAT => {
            const format = packed struct { red0: f16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @floatCast(f32, s.red0), 0.0, 0.0, 1.0 };
            }
        },
        .R16_SBFLOAT => {
            const format = packed struct { red0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @bitCast(f32, (@as(u32, s.red0) << 16) | 0), 0.0, 0.0, 1.0 };
            }
        },
        .R8G8B8_UNORM => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 1.0 };
            }
        },
        .R8G8B8_SNORM => {
            const format = packed struct { red0: i8, green0: i8, blue0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.00784313725490196, 0.00784313725490196, 0.00784313725490196, 1.0 };
            }
        },
        .R8G8B8_UINT => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 };
            }
        },
        .R8G8B8_SINT => {
            const format = packed struct { red0: i8, green0: i8, blue0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 };
            }
        },
        .R8G8B8_SRGB => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ sRGBTable[s.red0], sRGBTable[s.green0], sRGBTable[s.blue0], 1.0 };
            }
        },
        .B8G8R8_UNORM => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 1.0 };
            }
        },
        .B8G8R8_SNORM => {
            const format = packed struct { blue0: i8, green0: i8, red0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.00784313725490196, 0.00784313725490196, 0.00784313725490196, 1.0 };
            }
        },
        .B8G8R8_UINT => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 };
            }
        },
        .B8G8R8_SINT => {
            const format = packed struct { blue0: i8, green0: i8, red0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 };
            }
        },
        .B8G8R8_SRGB => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ sRGBTable[s.red0], sRGBTable[s.green0], sRGBTable[s.blue0], 1.0 };
            }
        },
        .R8G8B8A8_UNORM => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8, alpha0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 0.00392156862745098 };
            }
        },
        .R8G8B8A8_SNORM => {
            const format = packed struct { red0: i8, green0: i8, blue0: i8, alpha0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.00784313725490196, 0.00784313725490196, 0.00784313725490196, 0.00784313725490196 };
            }
        },
        .R8G8B8A8_UINT => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8, alpha0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R8G8B8A8_SINT => {
            const format = packed struct { red0: i8, green0: i8, blue0: i8, alpha0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R8G8B8A8_SRGB => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8, alpha0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ sRGBTable[s.red0], sRGBTable[s.green0], sRGBTable[s.blue0], sRGBTable[s.alpha0] };
            }
        },
        .B8G8R8A8_UNORM => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8, alpha0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 0.00392156862745098 };
            }
        },
        .B8G8R8A8_SNORM => {
            const format = packed struct { blue0: i8, green0: i8, red0: i8, alpha0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.00784313725490196, 0.00784313725490196, 0.00784313725490196, 0.00784313725490196 };
            }
        },
        .B8G8R8A8_UINT => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8, alpha0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .B8G8R8A8_SINT => {
            const format = packed struct { blue0: i8, green0: i8, red0: i8, alpha0: i8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .B8G8R8A8_SRGB => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8, alpha0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ sRGBTable[s.red0], sRGBTable[s.green0], sRGBTable[s.blue0], sRGBTable[s.alpha0] };
            }
        },
        .R8G8B8X8_UNORM => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 1.0 };
            }
        },
        .B8G8R8X8_UNORM => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 1.0 };
            }
        },
        .R16G16_UNORM => {
            const format = packed struct { red0: u16, green0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 1.5259021896696422E-5, 1.5259021896696422E-5, 1.0, 1.0 };
            }
        },
        .G16R16_UNORM => {
            const format = packed struct { green0: u16, red0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 1.5259021896696422E-5, 1.5259021896696422E-5, 1.0, 1.0 };
            }
        },
        .R16G16_SNORM => {
            const format = packed struct { red0: i16, green0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 3.0518043793392844E-5, 3.0518043793392844E-5, 1.0, 1.0 };
            }
        },
        .G16R16_SNORM => {
            const format = packed struct { green0: i16, red0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 } * @Vector(4, f32){ 3.0518043793392844E-5, 3.0518043793392844E-5, 1.0, 1.0 };
            }
        },
        .R16G16_UINT => {
            const format = packed struct { red0: u16, green0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 };
            }
        },
        .R16G16_SINT => {
            const format = packed struct { red0: i16, green0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 };
            }
        },
        .R16G16_SFLOAT => {
            const format = packed struct { red0: f16, green0: f16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @floatCast(f32, s.red0), @floatCast(f32, s.green0), 0.0, 1.0 };
            }
        },
        .R16G16_SBFLOAT => {
            const format = packed struct { red0: u16, green0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @bitCast(f32, (@as(u32, s.red0) << 16) | 0), @bitCast(f32, (@as(u32, s.green0) << 16) | 0), 0.0, 1.0 };
            }
        },
        .R32_UINT => {
            const format = packed struct { red0: u32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 };
            }
        },
        .R32_SINT => {
            const format = packed struct { red0: i32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), 0.0, 0.0, 1.0 };
            }
        },
        .R32_SFLOAT => {
            const format = packed struct { red0: f32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ s.red0, 0.0, 0.0, 1.0 };
            }
        },
        .A2R10G10B10_UNORM => {
            const format = packed struct { alpha0: u2, red0: u10, green0: u10, blue0: u10 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 9.775171065493646E-4, 9.775171065493646E-4, 9.775171065493646E-4, 0.3333333333333333 };
            }
        },
        .A2R10G10B10_SNORM => {
            const format = packed struct { alpha0: i2, red0: i10, green0: i10, blue0: i10 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.0019550342130987292, 0.0019550342130987292, 0.0019550342130987292, 0.6666666666666666 };
            }
        },
        .A2R10G10B10_UINT => {
            const format = packed struct { alpha0: u2, red0: u10, green0: u10, blue0: u10 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .A2R10G10B10_SINT => {
            const format = packed struct { alpha0: i2, red0: i10, green0: i10, blue0: i10 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .A2B10G10R10_UNORM => {
            const format = packed struct { alpha0: u2, blue0: u10, green0: u10, red0: u10 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 9.775171065493646E-4, 9.775171065493646E-4, 9.775171065493646E-4, 0.3333333333333333 };
            }
        },
        .A2B10G10R10_SNORM => {
            const format = packed struct { alpha0: i2, blue0: i10, green0: i10, red0: i10 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.0019550342130987292, 0.0019550342130987292, 0.0019550342130987292, 0.6666666666666666 };
            }
        },
        .A2B10G10R10_UINT => {
            const format = packed struct { alpha0: u2, blue0: u10, green0: u10, red0: u10 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .A2B10G10R10_SINT => {
            const format = packed struct { alpha0: i2, blue0: i10, green0: i10, red0: i10 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R10G10B10A2_UNORM => {
            const format = packed struct { red0: u10, green0: u10, blue0: u10, alpha0: u2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 9.775171065493646E-4, 9.775171065493646E-4, 9.775171065493646E-4, 0.3333333333333333 };
            }
        },
        .R10G10B10A2_SNORM => {
            const format = packed struct { red0: i10, green0: i10, blue0: i10, alpha0: i2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.0019550342130987292, 0.0019550342130987292, 0.0019550342130987292, 0.6666666666666666 };
            }
        },
        .R10G10B10A2_UINT => {
            const format = packed struct { red0: u10, green0: u10, blue0: u10, alpha0: u2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R10G10B10A2_SINT => {
            const format = packed struct { red0: i10, green0: i10, blue0: i10, alpha0: i2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .B10G10R10A2_UNORM => {
            const format = packed struct { blue0: u10, green0: u10, red0: u10, alpha0: u2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 9.775171065493646E-4, 9.775171065493646E-4, 9.775171065493646E-4, 0.3333333333333333 };
            }
        },
        .B10G10R10A2_SNORM => {
            const format = packed struct { blue0: i10, green0: i10, red0: i10, alpha0: i2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 0.0019550342130987292, 0.0019550342130987292, 0.0019550342130987292, 0.6666666666666666 };
            }
        },
        .B10G10R10A2_UINT => {
            const format = packed struct { blue0: u10, green0: u10, red0: u10, alpha0: u2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .B10G10R10A2_SINT => {
            const format = packed struct { blue0: i10, green0: i10, red0: i10, alpha0: i2 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R16G16B16_UNORM => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 1.5259021896696422E-5, 1.5259021896696422E-5, 1.5259021896696422E-5, 1.0 };
            }
        },
        .R16G16B16_SNORM => {
            const format = packed struct { red0: i16, green0: i16, blue0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 } * @Vector(4, f32){ 3.0518043793392844E-5, 3.0518043793392844E-5, 3.0518043793392844E-5, 1.0 };
            }
        },
        .R16G16B16_UINT => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 };
            }
        },
        .R16G16B16_SINT => {
            const format = packed struct { red0: i16, green0: i16, blue0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 };
            }
        },
        .R16G16B16_SFLOAT => {
            const format = packed struct { red0: f16, green0: f16, blue0: f16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @floatCast(f32, s.red0), @floatCast(f32, s.green0), @floatCast(f32, s.blue0), 1.0 };
            }
        },
        .R16G16B16_SBFLOAT => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @bitCast(f32, (@as(u32, s.red0) << 16) | 0), @bitCast(f32, (@as(u32, s.green0) << 16) | 0), @bitCast(f32, (@as(u32, s.blue0) << 16) | 0), 1.0 };
            }
        },
        .R16G16B16A16_UNORM => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16, alpha0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 1.5259021896696422E-5, 1.5259021896696422E-5, 1.5259021896696422E-5, 1.5259021896696422E-5 };
            }
        },
        .R16G16B16A16_SNORM => {
            const format = packed struct { red0: i16, green0: i16, blue0: i16, alpha0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) } * @Vector(4, f32){ 3.0518043793392844E-5, 3.0518043793392844E-5, 3.0518043793392844E-5, 3.0518043793392844E-5 };
            }
        },
        .R16G16B16A16_UINT => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16, alpha0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R16G16B16A16_SINT => {
            const format = packed struct { red0: i16, green0: i16, blue0: i16, alpha0: i16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R16G16B16A16_SFLOAT => {
            const format = packed struct { red0: f16, green0: f16, blue0: f16, alpha0: f16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @floatCast(f32, s.red0), @floatCast(f32, s.green0), @floatCast(f32, s.blue0), @floatCast(f32, s.alpha0) };
            }
        },
        .R16G16B16A16_SBFLOAT => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16, alpha0: u16 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @bitCast(f32, (@as(u32, s.red0) << 16) | 0), @bitCast(f32, (@as(u32, s.green0) << 16) | 0), @bitCast(f32, (@as(u32, s.blue0) << 16) | 0), @bitCast(f32, (@as(u32, s.alpha0) << 16) | 0) };
            }
        },
        .R32G32_UINT => {
            const format = packed struct { red0: u32, green0: u32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 };
            }
        },
        .R32G32_SINT => {
            const format = packed struct { red0: i32, green0: i32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), 0.0, 1.0 };
            }
        },
        .R32G32_SFLOAT => {
            const format = packed struct { red0: f32, green0: f32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ s.red0, s.green0, 0.0, 1.0 };
            }
        },
        .R32G32B32_UINT => {
            const format = packed struct { red0: u32, green0: u32, blue0: u32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 };
            }
        },
        .R32G32B32_SINT => {
            const format = packed struct { red0: i32, green0: i32, blue0: i32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), 1.0 };
            }
        },
        .R32G32B32_SFLOAT => {
            const format = packed struct { red0: f32, green0: f32, blue0: f32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ s.red0, s.green0, s.blue0, 1.0 };
            }
        },
        .R32G32B32A32_UINT => {
            const format = packed struct { red0: u32, green0: u32, blue0: u32, alpha0: u32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R32G32B32A32_SINT => {
            const format = packed struct { red0: i32, green0: i32, blue0: i32, alpha0: i32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ @intToFloat(f32, s.red0), @intToFloat(f32, s.green0), @intToFloat(f32, s.blue0), @intToFloat(f32, s.alpha0) };
            }
        },
        .R32G32B32A32_SFLOAT => {
            const format = packed struct { red0: f32, green0: f32, blue0: f32, alpha0: f32 };
            const src = @ptrCast([*]const format, @alignCast(@alignOf(format), input.plane0))[0..(input.plane0.len / @sizeOf(format))];
            std.debug.assert(src.len != 0);
            for (src) |s, i| {
                output[(i * 1) + 0] = @Vector(4, f32){ s.red0, s.green0, s.blue0, s.alpha0 };
            }
        },
        else => {},
    }
}
