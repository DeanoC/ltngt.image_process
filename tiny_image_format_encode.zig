// Do Not Edit Autogenerated by tiny_image_format_generator

const TinyImageFormat = @import("tiny_image_format.zig").Format;
const std = @import("std");


// from D3DX_DXGIFormatConvert.inl
fn f32ToSrgb(in: f32) u8 {
    var v = in;
    if (v < 0.0031308) {
        v *= 12.92;
    } else {
        v = 1.055 * std.math.pow(@TypeOf(v), v, 1.0 / 2.4) - 0.055;
    }
    return @floatToInt(u8, v);
}
pub fn CanEncodePixelsToF32(fmt: TinyImageFormat) bool {
    switch (fmt) {
        .R1_UNORM => return true,
        .R2_UNORM => return true,
        .R4_UNORM => return true,
        .R4G4_UNORM => return true,
        .G4R4_UNORM => return true,
        .A8_UNORM => return true,
        .R8_UNORM => return true,
        .R8_SNORM => return true,
        .R8_UINT => return true,
        .R8_SINT => return true,
        .R8_SRGB => return true,
        .B2G3R3_UNORM => return true,
        .R4G4B4A4_UNORM => return true,
        .R4G4B4X4_UNORM => return true,
        .B4G4R4A4_UNORM => return true,
        .B4G4R4X4_UNORM => return true,
        .A4R4G4B4_UNORM => return true,
        .X4R4G4B4_UNORM => return true,
        .A4B4G4R4_UNORM => return true,
        .X4B4G4R4_UNORM => return true,
        .R5G6B5_UNORM => return true,
        .B5G6R5_UNORM => return true,
        .R5G5B5A1_UNORM => return true,
        .B5G5R5A1_UNORM => return true,
        .A1R5G5B5_UNORM => return true,
        .A1B5G5R5_UNORM => return true,
        .R5G5B5X1_UNORM => return true,
        .B5G5R5X1_UNORM => return true,
        .X1R5G5B5_UNORM => return true,
        .X1B5G5R5_UNORM => return true,
        .B2G3R3A8_UNORM => return true,
        .R8G8_UNORM => return true,
        .R8G8_SNORM => return true,
        .G8R8_UNORM => return true,
        .G8R8_SNORM => return true,
        .R8G8_UINT => return true,
        .R8G8_SINT => return true,
        .R8G8_SRGB => return true,
        .R16_UNORM => return true,
        .R16_SNORM => return true,
        .R16_UINT => return true,
        .R16_SINT => return true,
        .R16_SFLOAT => return true,
        .R16_SBFLOAT => return true,
        .R8G8B8_UNORM => return true,
        .R8G8B8_SNORM => return true,
        .R8G8B8_UINT => return true,
        .R8G8B8_SINT => return true,
        .R8G8B8_SRGB => return true,
        .B8G8R8_UNORM => return true,
        .B8G8R8_SNORM => return true,
        .B8G8R8_UINT => return true,
        .B8G8R8_SINT => return true,
        .B8G8R8_SRGB => return true,
        .R8G8B8A8_UNORM => return true,
        .R8G8B8A8_SNORM => return true,
        .R8G8B8A8_UINT => return true,
        .R8G8B8A8_SINT => return true,
        .R8G8B8A8_SRGB => return true,
        .B8G8R8A8_UNORM => return true,
        .B8G8R8A8_SNORM => return true,
        .B8G8R8A8_UINT => return true,
        .B8G8R8A8_SINT => return true,
        .B8G8R8A8_SRGB => return true,
        .R8G8B8X8_UNORM => return true,
        .B8G8R8X8_UNORM => return true,
        .R16G16_UNORM => return true,
        .G16R16_UNORM => return true,
        .R16G16_SNORM => return true,
        .G16R16_SNORM => return true,
        .R16G16_UINT => return true,
        .R16G16_SINT => return true,
        .R16G16_SFLOAT => return true,
        .R16G16_SBFLOAT => return true,
        .R32_UINT => return true,
        .R32_SINT => return true,
        .R32_SFLOAT => return true,
        .A2R10G10B10_UNORM => return true,
        .A2R10G10B10_SNORM => return true,
        .A2R10G10B10_UINT => return true,
        .A2R10G10B10_SINT => return true,
        .A2B10G10R10_UNORM => return true,
        .A2B10G10R10_SNORM => return true,
        .A2B10G10R10_UINT => return true,
        .A2B10G10R10_SINT => return true,
        .R10G10B10A2_UNORM => return true,
        .R10G10B10A2_SNORM => return true,
        .R10G10B10A2_UINT => return true,
        .R10G10B10A2_SINT => return true,
        .B10G10R10A2_UNORM => return true,
        .B10G10R10A2_SNORM => return true,
        .B10G10R10A2_UINT => return true,
        .B10G10R10A2_SINT => return true,
        .R16G16B16_UNORM => return true,
        .R16G16B16_SNORM => return true,
        .R16G16B16_UINT => return true,
        .R16G16B16_SINT => return true,
        .R16G16B16_SFLOAT => return true,
        .R16G16B16_SBFLOAT => return true,
        .R16G16B16A16_UNORM => return true,
        .R16G16B16A16_SNORM => return true,
        .R16G16B16A16_UINT => return true,
        .R16G16B16A16_SINT => return true,
        .R16G16B16A16_SFLOAT => return true,
        .R16G16B16A16_SBFLOAT => return true,
        .R32G32_UINT => return true,
        .R32G32_SINT => return true,
        .R32G32_SFLOAT => return true,
        .R32G32B32_UINT => return true,
        .R32G32B32_SINT => return true,
        .R32G32B32_SFLOAT => return true,
        .R32G32B32A32_UINT => return true,
        .R32G32B32A32_SINT => return true,
        .R32G32B32A32_SFLOAT => return true,
        else => return false,
    }
}

const Output = struct { plane0: []const u8, plane1: []const u8 = undefined };

pub fn EncodePixelsToF32(fmt: TinyImageFormat, input: []@Vector(4, f32), output: Output) void {
    switch (fmt) {
        .R1_UNORM => {
            const format = packed struct { red0: u1, red1: u1, red2: u1, red3: u1, red4: u1, red5: u1, red6: u1, red7: u1 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/8)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 8; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u1, input[si + 0][0] * 1.0), .red1 = @floatToInt(u1, input[si + 1][0] * 1.0), .red2 = @floatToInt(u1, input[si + 2][0] * 1.0), .red3 = @floatToInt(u1, input[si + 3][0] * 1.0), .red4 = @floatToInt(u1, input[si + 4][0] * 1.0), .red5 = @floatToInt(u1, input[si + 5][0] * 1.0), .red6 = @floatToInt(u1, input[si + 6][0] * 1.0), .red7 = @floatToInt(u1, input[si + 7][0] * 1.0), };
            }
        },
        .R2_UNORM => {
            const format = packed struct { red0: u2, red1: u2, red2: u2, red3: u2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/4)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 4; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u2, input[si + 0][0] * 3.0), .red1 = @floatToInt(u2, input[si + 1][0] * 3.0), .red2 = @floatToInt(u2, input[si + 2][0] * 3.0), .red3 = @floatToInt(u2, input[si + 3][0] * 3.0), };
            }
        },
        .R4_UNORM => {
            const format = packed struct { red0: u4, red1: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/2)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 2; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .red1 = @floatToInt(u4, input[si + 1][0] * 15.0), };
            }
        },
        .R4G4_UNORM => {
            const format = packed struct { red0: u4, green0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), };
            }
        },
        .G4R4_UNORM => {
            const format = packed struct { green0: u4, red0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), };
            }
        },
        .A8_UNORM => {
            const format = packed struct { alpha0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .alpha0 = @floatToInt(u8, input[si + 0][3] * 255.0), };
            }
        },
        .R8_UNORM => {
            const format = packed struct { red0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), };
            }
        },
        .R8_SNORM => {
            const format = packed struct { red0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0] * 127.5), };
            }
        },
        .R8_UINT => {
            const format = packed struct { red0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0]), };
            }
        },
        .R8_SINT => {
            const format = packed struct { red0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0]), };
            }
        },
        .R8_SRGB => {
            const format = packed struct { red0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = f32ToSrgb(@floatCast(f32, input[si + 0][0])), };
            }
        },
        .B2G3R3_UNORM => {
            const format = packed struct { blue0: u2, green0: u3, red0: u3 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u3, input[si + 0][0] * 7.0), .green0 = @floatToInt(u3, input[si + 0][1] * 7.0), .blue0 = @floatToInt(u2, input[si + 0][2] * 3.0), };
            }
        },
        .R4G4B4A4_UNORM => {
            const format = packed struct { red0: u4, green0: u4, blue0: u4, alpha0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), .blue0 = @floatToInt(u4, input[si + 0][2] * 15.0), .alpha0 = @floatToInt(u4, input[si + 0][3] * 15.0), };
            }
        },
        .R4G4B4X4_UNORM => {
            const format = packed struct { red0: u4, green0: u4, blue0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), .blue0 = @floatToInt(u4, input[si + 0][2] * 15.0), };
            }
        },
        .B4G4R4A4_UNORM => {
            const format = packed struct { blue0: u4, green0: u4, red0: u4, alpha0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), .blue0 = @floatToInt(u4, input[si + 0][2] * 15.0), .alpha0 = @floatToInt(u4, input[si + 0][3] * 15.0), };
            }
        },
        .B4G4R4X4_UNORM => {
            const format = packed struct { blue0: u4, green0: u4, red0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), .blue0 = @floatToInt(u4, input[si + 0][2] * 15.0), };
            }
        },
        .A4R4G4B4_UNORM => {
            const format = packed struct { alpha0: u4, red0: u4, green0: u4, blue0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), .blue0 = @floatToInt(u4, input[si + 0][2] * 15.0), .alpha0 = @floatToInt(u4, input[si + 0][3] * 15.0), };
            }
        },
        .X4R4G4B4_UNORM => {
            const format = packed struct { red0: u4, green0: u4, blue0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), .blue0 = @floatToInt(u4, input[si + 0][2] * 15.0), };
            }
        },
        .A4B4G4R4_UNORM => {
            const format = packed struct { alpha0: u4, blue0: u4, green0: u4, red0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), .blue0 = @floatToInt(u4, input[si + 0][2] * 15.0), .alpha0 = @floatToInt(u4, input[si + 0][3] * 15.0), };
            }
        },
        .X4B4G4R4_UNORM => {
            const format = packed struct { blue0: u4, green0: u4, red0: u4 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u4, input[si + 0][0] * 15.0), .green0 = @floatToInt(u4, input[si + 0][1] * 15.0), .blue0 = @floatToInt(u4, input[si + 0][2] * 15.0), };
            }
        },
        .R5G6B5_UNORM => {
            const format = packed struct { red0: u5, green0: u6, blue0: u5 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u6, input[si + 0][1] * 63.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), };
            }
        },
        .B5G6R5_UNORM => {
            const format = packed struct { blue0: u5, green0: u6, red0: u5 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u6, input[si + 0][1] * 63.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), };
            }
        },
        .R5G5B5A1_UNORM => {
            const format = packed struct { red0: u5, green0: u5, blue0: u5, alpha0: u1 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u5, input[si + 0][1] * 31.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), .alpha0 = @floatToInt(u1, input[si + 0][3] * 1.0), };
            }
        },
        .B5G5R5A1_UNORM => {
            const format = packed struct { blue0: u5, green0: u5, red0: u5, alpha0: u1 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u5, input[si + 0][1] * 31.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), .alpha0 = @floatToInt(u1, input[si + 0][3] * 1.0), };
            }
        },
        .A1R5G5B5_UNORM => {
            const format = packed struct { alpha0: u1, red0: u5, green0: u5, blue0: u5 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u5, input[si + 0][1] * 31.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), .alpha0 = @floatToInt(u1, input[si + 0][3] * 1.0), };
            }
        },
        .A1B5G5R5_UNORM => {
            const format = packed struct { alpha0: u1, blue0: u5, green0: u5, red0: u5 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u5, input[si + 0][1] * 31.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), .alpha0 = @floatToInt(u1, input[si + 0][3] * 1.0), };
            }
        },
        .R5G5B5X1_UNORM => {
            const format = packed struct { red0: u5, green0: u5, blue0: u5 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u5, input[si + 0][1] * 31.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), };
            }
        },
        .B5G5R5X1_UNORM => {
            const format = packed struct { blue0: u5, green0: u5, red0: u5 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u5, input[si + 0][1] * 31.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), };
            }
        },
        .X1R5G5B5_UNORM => {
            const format = packed struct { red0: u5, green0: u5, blue0: u5 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u5, input[si + 0][1] * 31.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), };
            }
        },
        .X1B5G5R5_UNORM => {
            const format = packed struct { blue0: u5, green0: u5, red0: u5 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u5, input[si + 0][0] * 31.0), .green0 = @floatToInt(u5, input[si + 0][1] * 31.0), .blue0 = @floatToInt(u5, input[si + 0][2] * 31.0), };
            }
        },
        .B2G3R3A8_UNORM => {
            const format = packed struct { blue0: u2, green0: u3, red0: u2, alpha0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u2, input[si + 0][0] * 3.0), .green0 = @floatToInt(u3, input[si + 0][1] * 7.0), .blue0 = @floatToInt(u2, input[si + 0][2] * 3.0), .alpha0 = @floatToInt(u8, input[si + 0][3] * 255.0), };
            }
        },
        .R8G8_UNORM => {
            const format = packed struct { red0: u8, green0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), .green0 = @floatToInt(u8, input[si + 0][1] * 255.0), };
            }
        },
        .R8G8_SNORM => {
            const format = packed struct { red0: i8, green0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0] * 127.5), .green0 = @floatToInt(i8, input[si + 0][1] * 127.5), };
            }
        },
        .G8R8_UNORM => {
            const format = packed struct { green0: u8, red0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), .green0 = @floatToInt(u8, input[si + 0][1] * 255.0), };
            }
        },
        .G8R8_SNORM => {
            const format = packed struct { green0: i8, red0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0] * 127.5), .green0 = @floatToInt(i8, input[si + 0][1] * 127.5), };
            }
        },
        .R8G8_UINT => {
            const format = packed struct { red0: u8, green0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0]), .green0 = @floatToInt(u8, input[si + 0][1]), };
            }
        },
        .R8G8_SINT => {
            const format = packed struct { red0: i8, green0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0]), .green0 = @floatToInt(i8, input[si + 0][1]), };
            }
        },
        .R8G8_SRGB => {
            const format = packed struct { red0: u8, green0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = f32ToSrgb(@floatCast(f32, input[si + 0][0])), .green0 = f32ToSrgb(@floatCast(f32, input[si + 0][1])), };
            }
        },
        .R16_UNORM => {
            const format = packed struct { red0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0] * 65535.0), };
            }
        },
        .R16_SNORM => {
            const format = packed struct { red0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0] * 32767.5), };
            }
        },
        .R16_UINT => {
            const format = packed struct { red0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0]), };
            }
        },
        .R16_SINT => {
            const format = packed struct { red0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0]), };
            }
        },
        .R16_SFLOAT => {
            const format = packed struct { red0: f16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatCast(f16, input[si + 0][0]), };
            }
        },
        .R16_SBFLOAT => {
            const format = packed struct { red0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @truncate(u16, (@bitCast(u32, input[si + 0][0]) >> 16)), };
            }
        },
        .R8G8B8_UNORM => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), .green0 = @floatToInt(u8, input[si + 0][1] * 255.0), .blue0 = @floatToInt(u8, input[si + 0][2] * 255.0), };
            }
        },
        .R8G8B8_SNORM => {
            const format = packed struct { red0: i8, green0: i8, blue0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0] * 127.5), .green0 = @floatToInt(i8, input[si + 0][1] * 127.5), .blue0 = @floatToInt(i8, input[si + 0][2] * 127.5), };
            }
        },
        .R8G8B8_UINT => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0]), .green0 = @floatToInt(u8, input[si + 0][1]), .blue0 = @floatToInt(u8, input[si + 0][2]), };
            }
        },
        .R8G8B8_SINT => {
            const format = packed struct { red0: i8, green0: i8, blue0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0]), .green0 = @floatToInt(i8, input[si + 0][1]), .blue0 = @floatToInt(i8, input[si + 0][2]), };
            }
        },
        .R8G8B8_SRGB => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = f32ToSrgb(@floatCast(f32, input[si + 0][0])), .green0 = f32ToSrgb(@floatCast(f32, input[si + 0][1])), .blue0 = f32ToSrgb(@floatCast(f32, input[si + 0][2])), };
            }
        },
        .B8G8R8_UNORM => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), .green0 = @floatToInt(u8, input[si + 0][1] * 255.0), .blue0 = @floatToInt(u8, input[si + 0][2] * 255.0), };
            }
        },
        .B8G8R8_SNORM => {
            const format = packed struct { blue0: i8, green0: i8, red0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0] * 127.5), .green0 = @floatToInt(i8, input[si + 0][1] * 127.5), .blue0 = @floatToInt(i8, input[si + 0][2] * 127.5), };
            }
        },
        .B8G8R8_UINT => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0]), .green0 = @floatToInt(u8, input[si + 0][1]), .blue0 = @floatToInt(u8, input[si + 0][2]), };
            }
        },
        .B8G8R8_SINT => {
            const format = packed struct { blue0: i8, green0: i8, red0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0]), .green0 = @floatToInt(i8, input[si + 0][1]), .blue0 = @floatToInt(i8, input[si + 0][2]), };
            }
        },
        .B8G8R8_SRGB => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = f32ToSrgb(@floatCast(f32, input[si + 0][0])), .green0 = f32ToSrgb(@floatCast(f32, input[si + 0][1])), .blue0 = f32ToSrgb(@floatCast(f32, input[si + 0][2])), };
            }
        },
        .R8G8B8A8_UNORM => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8, alpha0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), .green0 = @floatToInt(u8, input[si + 0][1] * 255.0), .blue0 = @floatToInt(u8, input[si + 0][2] * 255.0), .alpha0 = @floatToInt(u8, input[si + 0][3] * 255.0), };
            }
        },
        .R8G8B8A8_SNORM => {
            const format = packed struct { red0: i8, green0: i8, blue0: i8, alpha0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0] * 127.5), .green0 = @floatToInt(i8, input[si + 0][1] * 127.5), .blue0 = @floatToInt(i8, input[si + 0][2] * 127.5), .alpha0 = @floatToInt(i8, input[si + 0][3] * 127.5), };
            }
        },
        .R8G8B8A8_UINT => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8, alpha0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0]), .green0 = @floatToInt(u8, input[si + 0][1]), .blue0 = @floatToInt(u8, input[si + 0][2]), .alpha0 = @floatToInt(u8, input[si + 0][3]), };
            }
        },
        .R8G8B8A8_SINT => {
            const format = packed struct { red0: i8, green0: i8, blue0: i8, alpha0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0]), .green0 = @floatToInt(i8, input[si + 0][1]), .blue0 = @floatToInt(i8, input[si + 0][2]), .alpha0 = @floatToInt(i8, input[si + 0][3]), };
            }
        },
        .R8G8B8A8_SRGB => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8, alpha0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = f32ToSrgb(@floatCast(f32, input[si + 0][0])), .green0 = f32ToSrgb(@floatCast(f32, input[si + 0][1])), .blue0 = f32ToSrgb(@floatCast(f32, input[si + 0][2])), .alpha0 = f32ToSrgb(@floatCast(f32, input[si + 0][3])), };
            }
        },
        .B8G8R8A8_UNORM => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8, alpha0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), .green0 = @floatToInt(u8, input[si + 0][1] * 255.0), .blue0 = @floatToInt(u8, input[si + 0][2] * 255.0), .alpha0 = @floatToInt(u8, input[si + 0][3] * 255.0), };
            }
        },
        .B8G8R8A8_SNORM => {
            const format = packed struct { blue0: i8, green0: i8, red0: i8, alpha0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0] * 127.5), .green0 = @floatToInt(i8, input[si + 0][1] * 127.5), .blue0 = @floatToInt(i8, input[si + 0][2] * 127.5), .alpha0 = @floatToInt(i8, input[si + 0][3] * 127.5), };
            }
        },
        .B8G8R8A8_UINT => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8, alpha0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0]), .green0 = @floatToInt(u8, input[si + 0][1]), .blue0 = @floatToInt(u8, input[si + 0][2]), .alpha0 = @floatToInt(u8, input[si + 0][3]), };
            }
        },
        .B8G8R8A8_SINT => {
            const format = packed struct { blue0: i8, green0: i8, red0: i8, alpha0: i8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i8, input[si + 0][0]), .green0 = @floatToInt(i8, input[si + 0][1]), .blue0 = @floatToInt(i8, input[si + 0][2]), .alpha0 = @floatToInt(i8, input[si + 0][3]), };
            }
        },
        .B8G8R8A8_SRGB => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8, alpha0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = f32ToSrgb(@floatCast(f32, input[si + 0][0])), .green0 = f32ToSrgb(@floatCast(f32, input[si + 0][1])), .blue0 = f32ToSrgb(@floatCast(f32, input[si + 0][2])), .alpha0 = f32ToSrgb(@floatCast(f32, input[si + 0][3])), };
            }
        },
        .R8G8B8X8_UNORM => {
            const format = packed struct { red0: u8, green0: u8, blue0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), .green0 = @floatToInt(u8, input[si + 0][1] * 255.0), .blue0 = @floatToInt(u8, input[si + 0][2] * 255.0), };
            }
        },
        .B8G8R8X8_UNORM => {
            const format = packed struct { blue0: u8, green0: u8, red0: u8 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u8, input[si + 0][0] * 255.0), .green0 = @floatToInt(u8, input[si + 0][1] * 255.0), .blue0 = @floatToInt(u8, input[si + 0][2] * 255.0), };
            }
        },
        .R16G16_UNORM => {
            const format = packed struct { red0: u16, green0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0] * 65535.0), .green0 = @floatToInt(u16, input[si + 0][1] * 65535.0), };
            }
        },
        .G16R16_UNORM => {
            const format = packed struct { green0: u16, red0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0] * 65535.0), .green0 = @floatToInt(u16, input[si + 0][1] * 65535.0), };
            }
        },
        .R16G16_SNORM => {
            const format = packed struct { red0: i16, green0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0] * 32767.5), .green0 = @floatToInt(i16, input[si + 0][1] * 32767.5), };
            }
        },
        .G16R16_SNORM => {
            const format = packed struct { green0: i16, red0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0] * 32767.5), .green0 = @floatToInt(i16, input[si + 0][1] * 32767.5), };
            }
        },
        .R16G16_UINT => {
            const format = packed struct { red0: u16, green0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0]), .green0 = @floatToInt(u16, input[si + 0][1]), };
            }
        },
        .R16G16_SINT => {
            const format = packed struct { red0: i16, green0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0]), .green0 = @floatToInt(i16, input[si + 0][1]), };
            }
        },
        .R16G16_SFLOAT => {
            const format = packed struct { red0: f16, green0: f16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatCast(f16, input[si + 0][0]), .green0 = @floatCast(f16, input[si + 0][1]), };
            }
        },
        .R16G16_SBFLOAT => {
            const format = packed struct { red0: u16, green0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @truncate(u16, (@bitCast(u32, input[si + 0][0]) >> 16)), .green0 = @truncate(u16, (@bitCast(u32, input[si + 0][1]) >> 16)), };
            }
        },
        .R32_UINT => {
            const format = packed struct { red0: u32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u32, input[si + 0][0]), };
            }
        },
        .R32_SINT => {
            const format = packed struct { red0: i32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i32, input[si + 0][0]), };
            }
        },
        .R32_SFLOAT => {
            const format = packed struct { red0: f32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = input[si + 0][0], };
            }
        },
        .A2R10G10B10_UNORM => {
            const format = packed struct { alpha0: u2, red0: u10, green0: u10, blue0: u10 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u10, input[si + 0][0] * 1023.0), .green0 = @floatToInt(u10, input[si + 0][1] * 1023.0), .blue0 = @floatToInt(u10, input[si + 0][2] * 1023.0), .alpha0 = @floatToInt(u2, input[si + 0][3] * 3.0), };
            }
        },
        .A2R10G10B10_SNORM => {
            const format = packed struct { alpha0: i2, red0: i10, green0: i10, blue0: i10 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i10, input[si + 0][0] * 511.5), .green0 = @floatToInt(i10, input[si + 0][1] * 511.5), .blue0 = @floatToInt(i10, input[si + 0][2] * 511.5), .alpha0 = @floatToInt(i2, input[si + 0][3] * 1.5), };
            }
        },
        .A2R10G10B10_UINT => {
            const format = packed struct { alpha0: u2, red0: u10, green0: u10, blue0: u10 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u10, input[si + 0][0]), .green0 = @floatToInt(u10, input[si + 0][1]), .blue0 = @floatToInt(u10, input[si + 0][2]), .alpha0 = @floatToInt(u2, input[si + 0][3]), };
            }
        },
        .A2R10G10B10_SINT => {
            const format = packed struct { alpha0: i2, red0: i10, green0: i10, blue0: i10 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i10, input[si + 0][0]), .green0 = @floatToInt(i10, input[si + 0][1]), .blue0 = @floatToInt(i10, input[si + 0][2]), .alpha0 = @floatToInt(i2, input[si + 0][3]), };
            }
        },
        .A2B10G10R10_UNORM => {
            const format = packed struct { alpha0: u2, blue0: u10, green0: u10, red0: u10 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u10, input[si + 0][0] * 1023.0), .green0 = @floatToInt(u10, input[si + 0][1] * 1023.0), .blue0 = @floatToInt(u10, input[si + 0][2] * 1023.0), .alpha0 = @floatToInt(u2, input[si + 0][3] * 3.0), };
            }
        },
        .A2B10G10R10_SNORM => {
            const format = packed struct { alpha0: i2, blue0: i10, green0: i10, red0: i10 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i10, input[si + 0][0] * 511.5), .green0 = @floatToInt(i10, input[si + 0][1] * 511.5), .blue0 = @floatToInt(i10, input[si + 0][2] * 511.5), .alpha0 = @floatToInt(i2, input[si + 0][3] * 1.5), };
            }
        },
        .A2B10G10R10_UINT => {
            const format = packed struct { alpha0: u2, blue0: u10, green0: u10, red0: u10 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u10, input[si + 0][0]), .green0 = @floatToInt(u10, input[si + 0][1]), .blue0 = @floatToInt(u10, input[si + 0][2]), .alpha0 = @floatToInt(u2, input[si + 0][3]), };
            }
        },
        .A2B10G10R10_SINT => {
            const format = packed struct { alpha0: i2, blue0: i10, green0: i10, red0: i10 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i10, input[si + 0][0]), .green0 = @floatToInt(i10, input[si + 0][1]), .blue0 = @floatToInt(i10, input[si + 0][2]), .alpha0 = @floatToInt(i2, input[si + 0][3]), };
            }
        },
        .R10G10B10A2_UNORM => {
            const format = packed struct { red0: u10, green0: u10, blue0: u10, alpha0: u2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u10, input[si + 0][0] * 1023.0), .green0 = @floatToInt(u10, input[si + 0][1] * 1023.0), .blue0 = @floatToInt(u10, input[si + 0][2] * 1023.0), .alpha0 = @floatToInt(u2, input[si + 0][3] * 3.0), };
            }
        },
        .R10G10B10A2_SNORM => {
            const format = packed struct { red0: i10, green0: i10, blue0: i10, alpha0: i2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i10, input[si + 0][0] * 511.5), .green0 = @floatToInt(i10, input[si + 0][1] * 511.5), .blue0 = @floatToInt(i10, input[si + 0][2] * 511.5), .alpha0 = @floatToInt(i2, input[si + 0][3] * 1.5), };
            }
        },
        .R10G10B10A2_UINT => {
            const format = packed struct { red0: u10, green0: u10, blue0: u10, alpha0: u2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u10, input[si + 0][0]), .green0 = @floatToInt(u10, input[si + 0][1]), .blue0 = @floatToInt(u10, input[si + 0][2]), .alpha0 = @floatToInt(u2, input[si + 0][3]), };
            }
        },
        .R10G10B10A2_SINT => {
            const format = packed struct { red0: i10, green0: i10, blue0: i10, alpha0: i2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i10, input[si + 0][0]), .green0 = @floatToInt(i10, input[si + 0][1]), .blue0 = @floatToInt(i10, input[si + 0][2]), .alpha0 = @floatToInt(i2, input[si + 0][3]), };
            }
        },
        .B10G10R10A2_UNORM => {
            const format = packed struct { blue0: u10, green0: u10, red0: u10, alpha0: u2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u10, input[si + 0][0] * 1023.0), .green0 = @floatToInt(u10, input[si + 0][1] * 1023.0), .blue0 = @floatToInt(u10, input[si + 0][2] * 1023.0), .alpha0 = @floatToInt(u2, input[si + 0][3] * 3.0), };
            }
        },
        .B10G10R10A2_SNORM => {
            const format = packed struct { blue0: i10, green0: i10, red0: i10, alpha0: i2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i10, input[si + 0][0] * 511.5), .green0 = @floatToInt(i10, input[si + 0][1] * 511.5), .blue0 = @floatToInt(i10, input[si + 0][2] * 511.5), .alpha0 = @floatToInt(i2, input[si + 0][3] * 1.5), };
            }
        },
        .B10G10R10A2_UINT => {
            const format = packed struct { blue0: u10, green0: u10, red0: u10, alpha0: u2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u10, input[si + 0][0]), .green0 = @floatToInt(u10, input[si + 0][1]), .blue0 = @floatToInt(u10, input[si + 0][2]), .alpha0 = @floatToInt(u2, input[si + 0][3]), };
            }
        },
        .B10G10R10A2_SINT => {
            const format = packed struct { blue0: i10, green0: i10, red0: i10, alpha0: i2 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i10, input[si + 0][0]), .green0 = @floatToInt(i10, input[si + 0][1]), .blue0 = @floatToInt(i10, input[si + 0][2]), .alpha0 = @floatToInt(i2, input[si + 0][3]), };
            }
        },
        .R16G16B16_UNORM => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0] * 65535.0), .green0 = @floatToInt(u16, input[si + 0][1] * 65535.0), .blue0 = @floatToInt(u16, input[si + 0][2] * 65535.0), };
            }
        },
        .R16G16B16_SNORM => {
            const format = packed struct { red0: i16, green0: i16, blue0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0] * 32767.5), .green0 = @floatToInt(i16, input[si + 0][1] * 32767.5), .blue0 = @floatToInt(i16, input[si + 0][2] * 32767.5), };
            }
        },
        .R16G16B16_UINT => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0]), .green0 = @floatToInt(u16, input[si + 0][1]), .blue0 = @floatToInt(u16, input[si + 0][2]), };
            }
        },
        .R16G16B16_SINT => {
            const format = packed struct { red0: i16, green0: i16, blue0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0]), .green0 = @floatToInt(i16, input[si + 0][1]), .blue0 = @floatToInt(i16, input[si + 0][2]), };
            }
        },
        .R16G16B16_SFLOAT => {
            const format = packed struct { red0: f16, green0: f16, blue0: f16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatCast(f16, input[si + 0][0]), .green0 = @floatCast(f16, input[si + 0][1]), .blue0 = @floatCast(f16, input[si + 0][2]), };
            }
        },
        .R16G16B16_SBFLOAT => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @truncate(u16, (@bitCast(u32, input[si + 0][0]) >> 16)), .green0 = @truncate(u16, (@bitCast(u32, input[si + 0][1]) >> 16)), .blue0 = @truncate(u16, (@bitCast(u32, input[si + 0][2]) >> 16)), };
            }
        },
        .R16G16B16A16_UNORM => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16, alpha0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0] * 65535.0), .green0 = @floatToInt(u16, input[si + 0][1] * 65535.0), .blue0 = @floatToInt(u16, input[si + 0][2] * 65535.0), .alpha0 = @floatToInt(u16, input[si + 0][3] * 65535.0), };
            }
        },
        .R16G16B16A16_SNORM => {
            const format = packed struct { red0: i16, green0: i16, blue0: i16, alpha0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0] * 32767.5), .green0 = @floatToInt(i16, input[si + 0][1] * 32767.5), .blue0 = @floatToInt(i16, input[si + 0][2] * 32767.5), .alpha0 = @floatToInt(i16, input[si + 0][3] * 32767.5), };
            }
        },
        .R16G16B16A16_UINT => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16, alpha0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u16, input[si + 0][0]), .green0 = @floatToInt(u16, input[si + 0][1]), .blue0 = @floatToInt(u16, input[si + 0][2]), .alpha0 = @floatToInt(u16, input[si + 0][3]), };
            }
        },
        .R16G16B16A16_SINT => {
            const format = packed struct { red0: i16, green0: i16, blue0: i16, alpha0: i16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i16, input[si + 0][0]), .green0 = @floatToInt(i16, input[si + 0][1]), .blue0 = @floatToInt(i16, input[si + 0][2]), .alpha0 = @floatToInt(i16, input[si + 0][3]), };
            }
        },
        .R16G16B16A16_SFLOAT => {
            const format = packed struct { red0: f16, green0: f16, blue0: f16, alpha0: f16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatCast(f16, input[si + 0][0]), .green0 = @floatCast(f16, input[si + 0][1]), .blue0 = @floatCast(f16, input[si + 0][2]), .alpha0 = @floatCast(f16, input[si + 0][3]), };
            }
        },
        .R16G16B16A16_SBFLOAT => {
            const format = packed struct { red0: u16, green0: u16, blue0: u16, alpha0: u16 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @truncate(u16, (@bitCast(u32, input[si + 0][0]) >> 16)), .green0 = @truncate(u16, (@bitCast(u32, input[si + 0][1]) >> 16)), .blue0 = @truncate(u16, (@bitCast(u32, input[si + 0][2]) >> 16)), .alpha0 = @truncate(u16, (@bitCast(u32, input[si + 0][3]) >> 16)), };
            }
        },
        .R32G32_UINT => {
            const format = packed struct { red0: u32, green0: u32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u32, input[si + 0][0]), .green0 = @floatToInt(u32, input[si + 0][1]), };
            }
        },
        .R32G32_SINT => {
            const format = packed struct { red0: i32, green0: i32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i32, input[si + 0][0]), .green0 = @floatToInt(i32, input[si + 0][1]), };
            }
        },
        .R32G32_SFLOAT => {
            const format = packed struct { red0: f32, green0: f32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = input[si + 0][0], .green0 = input[si + 0][1], };
            }
        },
        .R32G32B32_UINT => {
            const format = packed struct { red0: u32, green0: u32, blue0: u32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u32, input[si + 0][0]), .green0 = @floatToInt(u32, input[si + 0][1]), .blue0 = @floatToInt(u32, input[si + 0][2]), };
            }
        },
        .R32G32B32_SINT => {
            const format = packed struct { red0: i32, green0: i32, blue0: i32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i32, input[si + 0][0]), .green0 = @floatToInt(i32, input[si + 0][1]), .blue0 = @floatToInt(i32, input[si + 0][2]), };
            }
        },
        .R32G32B32_SFLOAT => {
            const format = packed struct { red0: f32, green0: f32, blue0: f32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = input[si + 0][0], .green0 = input[si + 0][1], .blue0 = input[si + 0][2], };
            }
        },
        .R32G32B32A32_UINT => {
            const format = packed struct { red0: u32, green0: u32, blue0: u32, alpha0: u32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(u32, input[si + 0][0]), .green0 = @floatToInt(u32, input[si + 0][1]), .blue0 = @floatToInt(u32, input[si + 0][2]), .alpha0 = @floatToInt(u32, input[si + 0][3]), };
            }
        },
        .R32G32B32A32_SINT => {
            const format = packed struct { red0: i32, green0: i32, blue0: i32, alpha0: i32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = @floatToInt(i32, input[si + 0][0]), .green0 = @floatToInt(i32, input[si + 0][1]), .blue0 = @floatToInt(i32, input[si + 0][2]), .alpha0 = @floatToInt(i32, input[si + 0][3]), };
            }
        },
        .R32G32B32A32_SFLOAT => {
            const format = packed struct { red0: f32, green0: f32, blue0: f32, alpha0: f32 };
            const dest = @ptrCast([*]const format, @alignCast(@alignOf(format), output.plane0))[0..(output.plane0.len/1)];
            var si = 0;
            var di = 0;
            while(si < input.len) : ({si += 1; di +=1;}) {
               dest[di] = format{ .red0 = input[si + 0][0], .green0 = input[si + 0][1], .blue0 = input[si + 0][2], .alpha0 = input[si + 0][3], };
            }
        },
        else => {},
    }
}
